class PremiumModal:
    """
    Apple-style modal with backdrop blur and smooth animations.
    """
    def __init__(self, title, message, buttons=None):
        self.title = title
        self.message = message
        self.buttons = buttons or [{'text': 'OK', 'style': 'primary'}]
        
        self.visible = False
        self.animation_progress = 0.0
        self.target_progress = 0.0
        
        self.width = 400
        self.height = 200
        self.center_x = 0
        self.center_y = 0
    
    def show(self):
        self.visible = True
        self.target_progress = 1.0
    
    def hide(self):
        self.target_progress = 0.0
    
    def update(self, screen_size):
        if self.target_progress == 0.0 and self.animation_progress < 0.01:
            self.visible = False
        
        # Smooth ease-out animation
        diff = self.target_progress - self.animation_progress
        self.animation_progress += diff * 0.12
        
        # Center calculation
        self.center_x = screen_size[0] // 2
        self.center_y = screen_size[1] // 2
        
        # Scale effect (pop in)
        scale = 0.95 + (0.05 * self._ease_out_back(self.animation_progress))
        self.current_width = int(self.width * scale)
        self.current_height = int(self.height * scale)
    
    def draw(self, surface, font_title, font_body):
        if not self.visible and self.animation_progress < 0.01:
            return
        
        # Backdrop blur effect (simplified)
        backdrop = pygame.Surface(surface.get_size(), pygame.SRCALPHA)
        backdrop.fill((0, 0, 0, int(40 * self.animation_progress)))
        surface.blit(backdrop, (0, 0))
        
        # Modal container
        modal_rect = pygame.Rect(0, 0, self.current_width, self.current_height)
        modal_rect.center = (self.center_x, self.center_y)
        
        # Modal background with shadow
        shadow_offset = 20
        shadow_surface = pygame.Surface(
            (self.current_width + shadow_offset * 2,
             self.current_height + shadow_offset * 2),
            pygame.SRCALPHA
        )
        pygame.draw.rounded_rect(
            shadow_surface,
            (*COLORS['shadow_medium'], int(80 * self.animation_progress)),
            shadow_surface.get_rect(),
            CORNER_RADIUS['lg']
        )
        surface.blit(
            shadow_surface,
            (modal_rect.x - shadow_offset, modal_rect.y - shadow_offset)
        )
        
        # Main modal
        pygame.draw.rounded_rect(
            surface,
            COLORS['surface'],
            modal_rect,
            CORNER_RADIUS['lg']
        )
        
        # Title
        title_surface = font_title.render(self.title, True, COLORS['text_primary'])
        title_rect = title_surface.get_rect(
            midtop=(modal_rect.centerx, modal_rect.top + SPACING['lg'])
        )
        surface.blit(title_surface, title_rect)
        
        # Message
        message_lines = self._wrap_text(self.message, font_body, modal_rect.width - SPACING['lg'] * 2)
        y_offset = title_rect.bottom + SPACING['md']
        for line in message_lines:
            line_surface = font_body.render(line, True, COLORS['text_secondary'])
            line_rect = line_surface.get_rect(
                midtop=(modal_rect.centerx, y_offset)
            )
            surface.blit(line_surface, line_rect)
            y_offset += line_surface.get_height() + 4
        
        # Buttons
        button_y = modal_rect.bottom - SPACING['lg'] - 36
        total_button_width = sum(len(btn['text']) * 8 + 80 for btn in self.buttons)
        x_offset = modal_rect.centerx - total_button_width // 2
        
        for btn_data in self.buttons:
            btn_width = len(btn_data['text']) * 8 + 80
            btn_rect = pygame.Rect(x_offset, button_y, btn_width, 36)
            
            # Draw button (simplified)
            bg_color = COLORS['primary'] if btn_data.get('style') == 'primary' else COLORS['background']
            pygame.draw.rounded_rect(surface, bg_color, btn_rect, CORNER_RADIUS['sm'])
            
            text_color = '#FFFFFF' if btn_data.get('style') == 'primary' else COLORS['primary']
            text_surf = font_body.render(btn_data['text'], True, text_color)
            text_rect = text_surf.get_rect(center=btn_rect.center)
            surface.blit(text_surf, text_rect)
            
            x_offset += btn_width + SPACING['sm']
    
    def _ease_out_back(self, x):
        """Easing function for smooth pop-in animation."""
        c1 = 1.70158
        c3 = c1 + 1
        return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2)
    
    def _wrap_text(self, text, font, max_width):
        """Wrap text to fit within max_width."""
        words = text.split(' ')
        lines = []
        current_line = []
        
        for word in words:
            test_line = ' '.join(current_line + [word])
            if font.size(test_line)[0] <= max_width:
                current_line.append(word)
            else:
                lines.append(' '.join(current_line))
                current_line = [word]
        
        lines.append(' '.join(current_line))
        return lines
